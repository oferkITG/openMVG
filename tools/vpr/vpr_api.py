from pathlib import Path

import cv2
import numpy as np
import torch

from tools.vpr.models.cosplace.cosplace_network import GeoLocalizationNet
from tools.vpr.options import options

encoder_type = "cosplace" # change here to "cosplace" if you'd like
device_id = "cuda:0"

encoder_options = options[encoder_type]
backbone = encoder_options["backbone"]
dim = encoder_options["dim"]
encoder_transform = encoder_options["transforms"]["shelef_transform"] # treat the same as shelef
device = torch.device(device_id if torch.cuda.is_available() else 'cpu')
print("In Python Module")
print("Loading {} VPR encoder with a [{}] backbone and descriptor dimension: [{}]:".format(encoder_type, backbone, dim))
# vpr_encoder = torch.hub.load("gmberton/{}".format(encoder_type), "get_trained_model",
#                      backbone=backbone, fc_output_dim=dim)
vpr_encoder = GeoLocalizationNet(backbone, fc_output_dim=dim)
vpr_encoder.load_state_dict(
    torch.load(Path(__file__).parent.parent.parent.joinpath('assets', 'weights', 'ResNet50_2048_cosplace.pth'),
               map_location=device_id))
vpr_encoder.to(device)
print("Network loaded to {}".format(device_id))

def encode_img(img: np.ndarray):
    '''

    :param img: h x w x 3 array representing an RGB image
    :return: vec: d-size vector, giving the global descriptor of the image, generated by
                  encoding the image with the encoder defined above
    '''
    print("Encoding image with {} encoder".format(encoder_type))
    print("Transform image to tensor, normalize and put on device")
    img = encoder_transform(img).unsqueeze(0).to(device)
    vpr_encoder.eval()
    with torch.no_grad():
        desc = vpr_encoder(img)
    desc = desc.squeeze(0).cpu().numpy()
    print("Image encoded to a {}-dim descriptor".format(desc.shape[0]))
    return desc





if __name__ == '__main__':

    img_path = "../../../shelef_b2/AAE_0502.JPG"
    print("Loading image: {}".format(img_path))
    img = cv2.cvtColor(cv2.imread(img_path), cv2.COLOR_BGR2RGB)
    desc = encode_img(img)
